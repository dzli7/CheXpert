# -*- coding: utf-8 -*-
"""faster_diaphragm_removal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GXzaWnrBNLDLCTx_7jPqP1MaKv2aUeoW
"""

import numpy as np
import cv2
from google.colab.patches import cv2_imshow
from PIL import Image
from IPython.display import display

def remove_diaphragm(path):
  img = cv2.imread(path, 1)
  img_copy = np.copy(img)
  img_copy_master = np.copy(img)

  max_pixel = 0
  min_pixel = 300

  print("Original")
  # cv2_imshow(img)


  ret, img = cv2.threshold(img, 229.5, 255, cv2.THRESH_BINARY)
  # Inverted Binary Image
  # cv2_imshow(img)



  # Convert to grayscale for connectedComponentsWithStats to work
  gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  print("inverted image")
  # cv2_imshow(gray)

  components = cv2.connectedComponentsWithStats(gray)
  (numLabels, labels, stats, centroids) = components

  # Find max area and start at 1 because 0 is background
  areas = []
  for i in range(1, numLabels):
    areas.append(stats[i, cv2.CC_STAT_AREA])

  mask = np.zeros(gray.shape, dtype="uint8")

  # Keep largest area and remove others
  max_area = max(areas)
  for i in range(numLabels):
    area = stats[i, cv2.CC_STAT_AREA]
    if area == max_area:
      componentMask = (labels == i).astype("uint8") * 255
      mask = cv2.bitwise_or(mask, componentMask)
    
  #cv2_imshow(mask)

  # Fill holes with closing
  kernel = np.ones((20,20),np.uint8)
  closing = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
  #cv2_imshow(closing)

  # Smooth boundary
  kernel = np.ones((20,20),np.uint8)
  opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel)

  # ret, opening = cv2.threshold(opening, 229.5, 255, cv2.THRESH_BINARY_INV)
  cv2.imwrite(path[0:(len(path)-4)] + 'mask.jpg', opening)
  # cv2_imshow(opening)

  img1 = Image.open(path)
  
  # Opening the secondary image (overlay image)
  img2 = Image.open(path[0:(len(path)-4)] + 'mask.jpg')    
    
  # Pasting img2 image on top of img1 
  # starting at coordinates (0, 0)
  img1.paste(img2, (0,0), mask = img2)

  na = np.array(img1.convert('L'))

  # Get x,y coordinates of black pixels
  Y, X = np.where(na==255)

  # Make pixels 30 across and 30 down from them black
  na[Y, X] = 0

  # Convert back to PIL Image and save
  img1 = Image.fromarray(na)
  # Displaying the image
  # display(img1)
  # img1 = img1.save("geeks.jpg")
  return img1

processed_image = remove_diaphragm('edema.jpg')

# Opening the primary image (used in background)
img1 = Image.open(r"edema.jpg")
  
# Opening the secondary image (overlay image)
img2 = Image.open(r"edema_mask.jpg")    
  
# Pasting img2 image on top of img1 
# starting at coordinates (0, 0)
img1.paste(img2, (0,0), mask = img2)

na = np.array(img1.convert('L'))

# Get x,y coordinates of black pixels
Y, X = np.where(na==255)

# Make pixels 30 across and 30 down from them black
na[Y, X] = 0

# Convert back to PIL Image and save
img1 = Image.fromarray(na)
# Displaying the image
display(img1)
# img1 = img1.save("geeks.jpg")